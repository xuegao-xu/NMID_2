# JavaScript

- JavaScript负责页面中的的行为。
- 它是一门运行在浏览器端的脚本语言。

## JS的编写的位置

1.可以编写到标签的指定属性中

```
<button onclick="alert('hello');">我是按钮</button>  
<a href="javascript:alert('aaa');">超链接</a>  
```

2.可以编写到script标签中

```
<script type="text/javascript">  
//编写js代码  
</script>  
```

3.可以将代码编写到外部的js文件中，然后通过标签将其引入(推荐使用的方式)

script标签一旦用于引入外部文件了，就不能在编写代码了，即使编写了浏览器也会忽略 ,如果需要则可以在创建一个新的script标签用于编写内部代码

```
<script type="text/javascript" src="文件路径"></script>  
```

## 输出语句

```
alert("要输出的内容");  
```

该语句会在浏览器窗口中弹出一个警告框

```
document.write("要输出的内容");  
```

该内容将会被写到body标签中，并在页面中显示

```
console.log("要输出的内容");  
```

该内容会被写到开发者工具的控制台中

## 基本的语法

1. JS中严格区分大小写
2. JS中每一条语句以分号 ; 结尾,如果不写分号,浏览器会自动添加,但是会消耗一些系统资源,而且有些时候,浏览器会加错分号,所以在开发中分号必须写
3. JS中会忽略多个空格和换行,所以我们可以利用空格和换行对代码进行格式化
4. js函数声明不需要；分号，但是赋值语句要加；分号

```
function functionName(arg0,arg1,arg2){  
//函数声明  
}  
var functionName=function(arg0,arg1,arg2){  
//函数表达式  
};(注意分号)  
```

注释

单行注释

```
//注释内容  
```

多行注释

```
/*  
注释内容  
*/  
```

JS严格区分大小写

JS中每条语句以分号(;)结尾如果不写分号，浏览器会自动添加，但是会消耗一些系统资源， 而且有些时候，浏览器会加错分号，所以在开发中分号必须写

JS中会自动忽略多个空格和换行，所以我们可以利用空格和换行对代码进行格式化。

## 字面量和变量

### 字面量

字面量实际上就是一些固定的值，比如 1 2 3 4 true false null NaN "hello"
**字面量都是不可以改变的。**

由于字面量不是很方便使用，所以在JS中很少直接使用字面量

### 变量

变量可以用来保存字面量，并且可以保存任意的字面量

一般都是通过变量来使用字面量，而不直接使用字面量，而且也可以通过变量来对字面量进行一个描述

声明变量

使用var关键字来声明一个变量

```
var a;  
```

为变量赋值

```
a = 1; 
```

声明和赋值同时进行

```
var a = 456;   
```

### 标识符

在JS中所有的可以自主命名的内容，都可以认为是一个标识符，
是标识符就应该遵守标识符的规范。

比如：变量名、函数名、属性名

命名一个标识符时需要遵守如下的规则：
1.标识符中可以含有字母、数字、_、$
2.标识符不能以数字开头
3.标识符不能是JS中的关键字和保留字
4.标识符一般采用驼峰命名法
helloWorld,xxxYyyZzz

# 数据类型

## 六种数据类型

**JS中一共分成六种数据类型 5个基本数据类型+object**
String 字符串
Number 数值
Boolean 布尔值
Null 空值
Undefined 未定义
Object 对象

其中基本数据类型有 5个,而 Object属于引用数据类型

#### **typeof运算符**

可以使用一个运算符 typeof，来检查一个变量的类型
语法: typeof 变量
检查字符串时,会返回 string
检查数值时,会返回 number

### 1.String 字符串

- JS中的字符串需要使用引号引起来

- 使用双引号或单引号都可以,但是不要混着用
- 引号不能嵌套,双引号不能放双引号,单引号不能放单引号

**转义字符**

在字符串中使用\作为转义字符

```
在字符串中我们可以使用\作为转义字符
当表示一些特殊符号时可以使用\进行转义
\"表示"
\'表示'
\n表示换行
\t制表符
\\表示\
```



### 2.Number 数值

**JS中所有的整数和浮点数都是Number类型**

最大能表示的值：Number.MAX_VALUE= 1.7976931348623157e+308

大于0的最小值：Number. MIN_VALUE = 5e-324

特殊数字：能赋值给变量
Infinity 正无穷 a = Infinity ,能赋值
-Infinity 负无穷
NaN 非法数字（Not A Number）

在JS中整数的运算基本可以保证精确
如果使用JS进行浮点运算,可能得到一个不精确的结果
所以千万不要使用JS进行对精确度要求比较高的运算，对精确度要求比较高的运算可以放到服务器进行运算

其他进制的数字的表示：

#### **JS其他进制表示**

在JS中,如果需要表示16进制的数字,则需要以0x开头
如果需要表示8进制的数字,则需要以0开头
如果要要表示2进制的数字,则需要以0b开头,但是不是所有浏览器都支持，chrome，火狐支持，IE不支持

```
//十六进制
a=0x10;
a 0xff;
a= 0xcafe;
//八进制数字
a=070;
//二进制数字
//a=0b10;

//向"070"这种字符串,有些浏览器会当成8进制解析,有些会当成10进制解析
a="070";
//可以在 parseInt()中传递一个第二个参数,来指定数字的进制
a= parseInt(a, 10);//a按十进制解析
```

使用typeof检查一个Number类型的数据时，会返回"number"（包括NaN 和 Infinity）

### 3.Boolean 布尔值

布尔值主要用来进行逻辑判断，布尔值只有两个
true 逻辑的真
false 逻辑的假
使用typeof检查一个布尔值时，会返回"boolean"

### 4.Null 空值

空值专门用来表示为空的对象，Null类型的值只有一个
null
使用typeof检查一个Null类型的值时会返回"object"

### 5.Undefined 未定义

**如果声明一个变量但是没有为变量赋值此时变量的值就是undefined**
该类型的值只有一个 undefined
使用typeof检查一个Undefined类型的值时，会返回"undefined"

### 引用数据类型

Object 对象



## 强制类型转换

类型转换就是指将其他的数据类型，转换为String Number 或 Boolean

### 转换为String

#### 方式一（强制类型转换）：

**调用被转换数据的toString()方法**
例子：
var a = 123;
a = a.toString();
注意：**这个方法不适用于null和undefined**
由于这两个类型的数据中没有toString()方法，所以调用toString()时会报错

#### 方式二（强制类型转换）：

调用 String()函数,并将被转换的数据作为参数传递给函数

使用 String()函数做强制类型转换时,
对于 Number和Boolean实际上就是调用的 toString()方法

但是对于nu11和 undefined,就不会调用 toString()方法
它会将null直接转换为"null"，将 undefined直接转换为"undefined"
例子：

```
var a = 123;  
a = String(a);  
```

#### 方式三（隐式的类型转换）:

**为任意的数据类型 +""**
例子：

```
var a = true;  
a = a + ""; 
```

原理：和String()函数一样

### 转换为Number

#### 方式一（强制类型转换）：

**调用Number()函数**

转换的情况：

1. 字符串 ---> 数字
   如果字符串是一个合法的数字，则直接转换为对应的数字
   如果字符串是一个非法的数字，则转换为NaN
   如果是一个空串或纯空格的字符串，则转换为0
2. 布尔值 ---> 数字
   true转换为1
   false转换为0
3. 空值 ---> 数字
   null转换为0
4. 未定义 ---> 数字
   undefined 转换为NaN

例子：

```
val a = "123";
a = Number(a);//123
a = "abc";
a = Number(a);//NaN
a = "";//0
a = ture;
a = Number(a);//1
a = false;
a = Number(a);//0
a = null;
a = Number(a);//0
a = undefined;
a = Number(a);//NaN
```

#### 方式二（强制类型转换）：

这两种方式专门用来对付字符串
parseInt()把一个字符串转换为一个整数
parsefloat()把一个字符串转换为一个浮点数

可以将**一个字符串中的有效的整数位**提取出来，并转换为Number
例子：

```
var a = "123.456px";  
a = parseInt(a); //123  
```

如果需要可以在parseInt()中指定一个第二个参数，来指定进制parseFloat()可以将一个**字符串中的有效的小数位**提取出来，并转换为Number
例子：

```
var a = "123.456px";  
a = parseFloat(a); //123.456  
```

如果对非String使用 parseInt()或 parseFloat()
它会先将其转换为 String然后在操作

```
val a = ture;
a = parseInt(a);//NaN
```

#### 方式三（隐式的类型转换）：

使用一元的+来进行隐式的类型转换
例子：

```
var a = "123";  
a = +a;  
```

**原理：和Number()函数一样**

### 转换为布尔值

#### 方式一（强制类型转换）：

**使用Boolean()函数**
字符串 > 布尔
除了空串其余全是true

数值 > 布尔
除了0和NaN其余的全是true

null、undefined > 布尔
都是false

对象 > 布尔
都是true

例子：

```
var s = "false";  
s = Boolean(s); //true 
```



#### 方式二（隐式类型转换）：

**为任意的数据类型做两次非运算，即可将其转换为布尔值**
例子：

```
var a = "hello";  
a = !!a; //true  
```

# 基础语法

## 运算符

运算符也称为操作符
通过运算符可以对一个或多个值进行运算或操作

### typeof运算符

用来检查一个变量的数据类型
语法：typeof 变量
它会返回一个用于描述类型的字符串作为结果number,string,boolean,undefined,object

### 算数运算符

+ +对两个值进行加法运算并返回结果

  + 如果对两个字符串进行加法运算,则会做拼串会将两个字符串拼接为一个字符串,并返回

  + 任何的值和字符串做加法运算,都会先转换为字符串,然后再和字符串做拼串的操作

    我们可以利用这一特点,来将一个任意的数据类型转换为 String
    我们只需要为任意的数据类型+一个” ”(空字符串)即可将其转换为 String
    这是一种隐式的类型转换,由浏览器自动完成,实际上它也是调用 String()函数
- -对两个值进行减法运算并返回结果
* *对两个值进行乘法运算并返回结果
* / 对两个值进行除法运算并返回结果
* % 对两个值进行取余运算并返回结果

任何值做-，\*，/运算时都会自动转换为 Number
我们可以利用这一特点做隐式的类型转换
可以通过为一个值-0，*1，/1来将其转换为 Number
原理和Number()函数一样,使用起来更加简单

### 一元运算符

一元运算符只需要一个操作数

#### 一元的+

就是正号，不会对值产生任何影响，但是可以将一个非数字转换为数字
例子：

```
var a = true;  
a = +a;  
```

#### 一元的-

就是负号，可以对一个数字进行符号位取反
例子：

```
var a = 10;  
a = a;  
```

对于非 Number类型的值,
它会将先转换为 Number,然后在运算
可以对一个其他的数据类型使用+,来将其转换为 number
它的原理和Number()函数一样



#### 自增

自增可以使变量在原值的基础上自增1
自增使用 ++
自增可以使用 前++（++a）后++(a++)
无论是++a 还是 a++都会立即使原变量自增1
不同的是++a和a++的值是不同的，
++a的值是变量的新值（自增后的值）
a++的值是变量的原值（自增前的值）

#### 自减

自减可以使变量在原值的基础上自减1
自减使用
自减可以使用 前（a）后(a)
无论是a 还是 a都会立即使原变量自减1
不同的是a和a的值是不同的，
a的值是变量的新值（自减后的值）
a的值是变量的原值（自减前的值）

### 逻辑运算符

!
非运算可以对一个布尔值进行取反，true变false false边true
当对非布尔值使用!时，会先将其转换为布尔值然后再取反
我们可以利用!来将其他的数据类型转换为布尔值

&&
&&可以对符号两侧的值进行与运算
只有两端的值都为true时，才会返回true。只要有一个false就会返回false。
与是一个短路的与，如果第一个值是false，则不再检查第二个值
对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值
规则：
1.如果第一个值为false，则返回第一个值
2.如果第一个值为true，则返回第二个值

||
||可以对符号两侧的值进行或运算
只有两端都是false时，才会返回false。只要有一个true，就会返回true。
或是一个短路的或，如果第一个值是true，则不再检查第二个值
对于非布尔值，它会将其转换为布尔值然后做运算，并返回原值
规则：
1.如果第一个值为true，则返回第一个值
2.如果第一个值为false，则返回第二个值

### 赋值运算符

=
可以将符号右侧的值赋值给左侧变量
+=

```
a += 5 相当于 a = a+5    
var str = "hello";  str += "world";  
```

-=

```
a -= 5  相当于 a = a-5  
```

*=

```
a *= 5 相当于 a = a*5  
```

/=

```
a /= 5 相当于 a = a/5	  
```

%=

```
a %= 5 相当于 a = a%5 
```

### 关系运算符

关系运算符用来比较两个值之间的大小关系的
\>
\>=
<
<=
关系运算符的规则和数学中一致，用来比较两个值之间的关系，
如果关系成立则返回true，关系不成立则返回false。
如果比较的两个值是非数值，会将其转换为Number然后再比较。
如果比较的两个值都是字符串，此时会一位一位比较字符串的Unicode编码，而不会转换为Number。

```
两个字符串数字相比时，一定要注意转型，可以通过+进行转型
console.log("12345" < +"3")
```

### Unicode编码

在JS字符串中使用转义字符输入 Unicode编码

```
"\u2020"
格式："\u四位编码"	这里的编码是十六进制的，Unicode编码默认是十六进制编码
```

在网页(body)中使用 Unicode编码

```
&#2020;
格式：&#编码;	这里的编码需要的是10进制,需要将十六进制编码转为十进制的
```


### 相等运算符

相等，判断左右两个值是否相等，如果相等返回true，如果不等返回false
相等会自动对两个值进行类型转换，如果**对不同的类型进行比较，会将其转换为相同的类型然后再比较**，转换后相等它也会返回true，null == undifined 会返回true

!=
不等，判断左右两个值是否不等，如果不等则返回true，如果相等则返回false
不等也会做自动的类型转换。

**===**
**全等**，判断左右两个值是否全等，它和相等类似，只不过它不会进行自动的类型转换，
如果两个值的类型不同，则直接返回false

!==
**不全等**，和不等类似，但是它不会进行自动的类型转换，如果两个值的类型不同，它会直接返回true

特殊的值：
null和undefined
由于undefined衍生自null，所以**null == undefined** 会返回true。
但是 null === undefined 会返回false。
**NaN**
NaN不与任何值相等，自身相比 NaN == NaN //false

判断一个值是否是NaN
使用isNaN()函数	返回值：true/false

### 三元运算符：

语法：条件表达式?语句1:语句2;
执行流程：
先对条件表达式求值判断，
如果判断结果为true，则执行语句1，并返回执行结果
如果判断结果为false，则执行语句2，并返回执行结果

```
var max= a>b?(a>c?a : c):(b>c?b : c);//求三个数最大值，不推荐使用这种，不方便阅读
```



优先级：
和数学中一样，JS中的运算符也是具有优先级的，
比如 先乘除 后加减 先与 后或
具体的优先级可以参考优先级的表格，在表格中越靠上的优先级越高，
优先级越高的越优先计算，优先级相同的，从左往右计算。
优先级不需要记忆，如果越到拿不准的，使用()来改变优先级。

### 代码块

我们的程序是由一条一条语句构成的
语句是按照自上向下的顺序一条一条执行的

在JS中可以使用{ }来为语句进行分组,
同一个{ }中的语句我们称为是一组语句,
它们要么都执行,要么都不执行,
一个{ }中的语句我们也称为叫一个代码块
在代码块的后边就不用再编写分号(;)了
JS中的代码块,只具有分组的的作用,没有其他的用途，



## 流程控制语句

程序都是自上向下的顺序执行的，
通过流程控制语句可以改变程序执行的顺序，或者反复的执行某一段的程序。

### 条件分支语句

条件判断语句也称为if语句
语法一：

```
if(条件表达式){  
	语句...  
}  
 执行流程：  
 if语句执行时，会先对条件表达式进行求值判断，  
 如果值为true，则执行if后的语句  
 如果值为false，则不执行  
```

语法二：

```
if(条件表达式){  
	语句...  
}else{  
	语句...  
} 
 执行流程：  
	if...else语句执行时，会对条件表达式进行求值判断，  
		如果值为true，则执行if后的语句  
		如果值为false，则执行else后的语句  
```

语法三：

```
if(条件表达式){  
	语句...  
}else if(条件表达式){  
	语句...  
}else if(条件表达式){  
	语句...  
}else if(条件表达式){  
	语句...  
}else{  
	语句...  
}	  
 执行流程  
	 if...else if...else语句执行时，会自上至下依次对条件表达式进行求值判断，  
		如果判断结果为true，则执行当前if后的语句，执行完成后语句结束。  
		如果判断结果为false，则继续向下判断，直到找到为true的为止。  
		如果所有的条件表达式都是false，则执行else后的语句  
		该语句中,只会有一个代码块被执行,一旦代码块执行了,则直接结束语句
```

### prompt()函数

prompt()可以弹出一个提示框,该提示框中会带有一个文本框,
用户可以在文本框中输入一段内容,该函数需要一个字符串作为参数,
该字符串将会作为提示框的提示文字
用户输入的内容将会作为函数的返回值返回,可以定义一个变量来接收该内容
注意：prompt()函数返回值是一个字符串




1.条件分支语句
switch语句
语法:

```
switch(条件表达式){  
	case 表达式:  
		语句...  
		break;  
	case 表达式:  
		语句...  
		break;  
	case 表达式:  
		语句...  
		break;  
	default:  
		语句...  
		break;  //break的作用是跳出switch语句体
}  
```

执行流程：
switch...case...语句在执行时，会依次将case后的表达式的值和switch后的表达式的值进行全等比较，
如果比较结果为false，则继续向下比较。如果比较结果为true，则从当前case处开始向下执行代码。
如果所有的case判断结果都为false，则从default处开始执行代码。

### 循环语句

通过循环语句可以反复执行某些语句多次
while循环
语法：

```
while(条件表达式){  
    语句...  
}  
```

执行流程：
while语句在执行时，会先对条件表达式进行求值判断，
如果判断结果为false，则终止循环
如果判断结果为true，则执行循环体
循环体执行完毕，继续对条件表达式进行求值判断，依此类推

do...while循环
语法:

```
do{  
语句...  
}while(条件表达式) 
```

执行流程
do...while在执行时，会先执行do后的循环体，然后在对条件表达式进行判断，
如果判断判断结果为false，则终止循环。
如果判断结果为true，则继续执行循环体，依此类推

和while的区别：
while：先判断后执行
do...while: 先执行后判断
do...while可以确保循环体至少执行一次。

for循环
语法：

```
for(①初始化表达式 ; ②条件表达式 ; ④更新表达式){  
    ③语句...  
}  
```

执行流程：
首先执行①初始化表达式，初始化一个变量，
然后对②条件表达式进行求值判断，如果为false则终止循环
如果判断结果为true，则执行③循环体
循环体执行完毕，执行④更新表达式，对变量进行更新。
更新表达式执行完毕重复②
这里面初始化表达式只会执行一次


死循环

```
for循环中的三个部分都可以省略,也可以写在外部
如果在for循环中不写任何的表达式,只写两个分号(;)
此时循环是一个死循环会一直执行下去,慎用 
for(;;){  

}

while死循环
while(true){  

}  
```

### break

break关键字可以用来退出 switch或循环语句
不能在if语句中使用 break和 continue
break关键字,会立即终止离他最近的那个循环语句

break也可以自定义想要结束的for循环
为循环语句创建一个label,来标识当前的循环
label(自定义名字):循环语句
使用 break语句时,可以在 break后跟着一个label
这样 break将会结柬指定的循环,而不是最近的

```
例子
outer:
for (var i=0:i<5 i++){
	console.1og("@外层循环"+i)
	for (var j=0;j<5; j++){
		break outer;		//这里结束的就是名字叫outer的for循环
		console.1og("内层循环:"+j);
	}
}
```



### continue

continue关键字可以用来跳过当次循环
同样 continue也是默认只会对离他最近的循环循环起作用

continue也可以自定义想要结束的for循环
为循环语句创建一个label,来标识当前的循环
label(自定义名字):循环语句
使用 continue语句时,可以在 continue后跟着一个label
这样 continue将会结柬指定的循环,而不是最近的

```
例子
outer:
for (var i=0:i<5 i++){
	console.1og("@外层循环"+i)
	for (var j=0;j<5; j++){
		continue outer;		//这里跳过的就是名字叫outer的for循环
		console.1og("内层循环:"+j);
	}
}
```

### 计时器

console.time("计时器的名字")可以用来开启一个计时器
console. timeEnd("计时器的名字")用来停止一个计时器
计时器需要一个字符串作为参数,这个字符串将会作为计时器的标识

```
console. time ("test")；//开启计时器
console. time End ("test");//终止计时器
```



# 对象（Object）

对象是JS中的引用数据类型
**对象是一种复合数据类型，在对象中可以保存多个不同数据类型的属性**
使用typeof检查一个对象时，会返回object

## 对象的分类：

1.内建对象
\- 由ES标准中定义的对象，在任何的ES的实现中都可以使用
\- 比如：Math String Number Boolean Function Object....

2.宿主对象
\- 由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象
\- 比如 BOM DOM

3.自定义对象

\- 由开发人员自己创建的对象 



**创建对象**
方式一：

```
	 var obj = new Object();  
```

方式二：

```
    var obj = {}; 
```

**向对象中添加属性**
语法：
对象.属性名 = 属性值;
**对象["属性名"] = 属性值;** //这种方式能够使用特殊的属性名

**对象的属性名没有任何要求，不需要遵守标识符的规范，但是在开发中，尽量按照标识符的要求去写。**
属性值也可以任意的数据类型。

读取对象中的属性
语法：
对象.属性名
对象["属性名"] //"属性名"可以是字符串常量，也可以是字符串变量
如果读取一个对象中没有的属性，它不会报错，而是返回一个undefined

**删除对象中的属性**
语法：

```
delete 对象.属性名;
delete 对象["属性名"];
```

## 遍历

**使用in检查对象中是否含有指定属性**
语法："属性名" in 对象
如果在对象中含有该属性，则返回true
如果没有则返回false

```
  循环遍历对象自身的和继承的可枚举属性(不含Symbol属性).  
var obj = {'0':'a','1':'b','2':'c'};  
  
for(var i in obj) {  
     console.log(i,":",obj[i]);  
}  
```


**使用对象字面量，在创建对象时直接向对象中添加属性**
语法：

```
var obj = {  
    属性名:属性值,  
    属性名:属性值,  
    属性名:属性值,  
    属性名:属性值  
} 

例子：(推荐使用这种格式，清晰明了)
var obj = {
    name:"猪八戒",
    age: 28,
    gender:"男"
};
console.log(obj);
```

**基本数据类型和引用数据类型**
基本数据类型
String Number Boolean Null Undefined
引用数据类型
Object
**基本数据类型的数据，变量是直接保存的它的值。**
变量与变量之间是互相独立的，修改一个变量不会影响其他的变量。
JS中的变量都是保存到栈内存中的

**引用数据类型的数据，变量是保存的对象的引用（内存地址）。**
JS中的对象是保存到堆内存中的
如果多个变量指向的是同一个对象，此时修改一个变量的属性，会影响其他的变量。
比较两个变量时，对于基本数据类型，比较的就是值，
对于引用数据类型比较的是地址，地址相同才相同



## 函数（Function）

**函数也是一个对象，也具有普通对象的功能（能有属性）**
函数中可以封装一些代码，在需要的时候可以去调用函数来执行这些代码
使用typeof检查一个函数时会返回function

创建函数对象
可以将要封装的代码以字符串的形式传递给构造函数(不推荐使用)

```
var fun= new Function(" conso1e.1og("He11o这是我的第一个函数');");
```

函数声明

```
function 函数名([形参1,形参2...形参N]){  
语句...  
}  
```

函数表达式

```
var 函数名 = function([形参1,形参2...形参N]){  
语句...  
}; //注意写逗号
```

调用函数
语法：函数对象([实参1,实参2...实参N]);
fun() sum() alert() Number() parseInt()
当我们调用函数时，函数中封装的代码会按照编写的顺序执行

**立即执行函数**
函数定义完，立即被调用，这种函数叫做立即执行函数
立即执行函数往往只会执行一次

```
格式:(function(){  

    })(); 
    
例子:(function(a,b){  
        console.log("a = "+a);  
        console.log("b = "+b);  
     })(123,456); 
```

### 遍历对象中的属性

```
语法:
for(var 变量 in  对象){

}
for……in语句对象中有几个属性,循环体就会执行几次
每次执行时,会将对象中的一个属性的名字赋值给变量

 例子：  for(var n in obj){
            console.1og("属性名:" + n);//遍历对象中的属性
            console.log(obj[n]);//遍历对象中的属性的值
        }

        for(var v in obj){  
            document.write("property：name ="+v+"value="+obj[v]+"<br/>" );  
        }  
```

形参和实参
形参：形式参数
定义函数时，可以在()中定义一个或多个形参，形参之间使用,隔开
定义形参就相当于在函数内声明了对应的变量但是并不赋值，
形参会在调用时才赋值。

实参：实际参数
调用函数时，可以在()传递实参，传递的实参会赋值给对应的形参,
调用函数时JS解析器不会检查实参的类型和个数，可以传递任意数据类型的值。
**如果实参的数量大于形参，多余实参将不会赋值，**
**如果实参的数量小于形参，则没有对应实参的形参将会赋值undefined**

**返回值，就是函数执行的结果。**
使用return 来设置函数的返回值。
语法：return 值;
该值就会成为函数的返回值，可以通过一个变量来接收返回值

**return后边的代码都不会执行，一旦执行到return语句时，函数将会立刻退出。**
**return后可以跟任意类型的值，可以是基本数据类型，也可以是一个对象，也可以是一个函数。**
**如果return后不跟值，或者是不写return则函数默认返回undefined。**



**参数，函数的实参可以是任意的数据类型，也可以是对象，还可以是一个函数**

```
mianji()
调用函数
相当于使用的函数的返回值

manji
函数对象
相当于直接使用函数对象		//注意区分这两个的含义
```


**方法（method）**
可以将一个函数设置为一个对象的属性，
当一个对象的属性是一个函数时，
我们称这个函数是该对象的方法。
对象.方法名();
函数名()

### 函数的属性和方法

call()
apply()
**这两个方法都是函数对象的方法需要通过函数对象来调用**
通过两个方法可以直接调用函数，并且**可以通过第一个实参来指定函数中this**
不同的是call是直接传递函数的实参而apply需要将实参封装到一个数组中传递
**arguments**
arguments和this类似，都是函数中的隐含的参数
arguments是一个类数组元素，它用来封装函数执行过程中的实参
所以即使不定义形参，也可以通过arguments来使用实参
**arguments中有一个属性callee表示当前执行的函数对象**

this（调用函数的那个对象）
this是函数的上下文对象，根据函数的调用方式不同会执向不同的对象
1.以函数的形式调用时，this是window
2.以方法的形式调用时，this是调用方法的对象
3.以构造函数的形式调用时，this是新建的那个对象
4.使用call和apply调用时，this是指定的那个对象
5.在全局作用域中this代表window

## 作用域

作用域简单来说就是一个变量的作用范围。
在JS中作用域分成两种：

**1.全局作用域**

直接在script标签中编写的代码都运行在全局作用域中
**全局作用域在打开页面时创建，在页面关闭时销毁。**
全局作用域中有一个全局对象window，window对象由浏览器提供，
可以在页面中直接使用，它代表的是整个的浏览器的窗口。
**在全局作用域中创建的变量都会作为window对象的属性保存**
在全局作用域中创建的函数都会作为window对象的方法保存
在全局作用域中创建的变量和函数可以在页面的任意位置访问。
在函数作用域中也可以访问到全局作用域的变量。
尽量不要在全局中创建变量

**2.函数作用域**

函数作用域是函数执行时创建的作用域，每次调用函数都会创建一个新的函数作用域。
函数作用域在函数执行时创建，在函数执行结束时销毁。
在函数作用域中创建的变量，不能在全局中访问。
在函数作用域中可以访问到全局作用域的变量
当在函数作用域中使用一个变量时，它会先在自身作用域中寻找，
如果找到了则直接使用，如果没有找到则到上一级作用域中寻找，
如果找到了则使用，找不到则继续向上找，直到找到全局作用城
如果全局作用域中依然没有找到,则会报错 Referenceerror
在函数中要访间全局变量可以使用 window对象

在函数作用域也有声明提前的特性,
使用var关键字声明的变量,会在函数中所有的代码执行之前被声明
函数声明也会在函数中所有的代码执行之前执行
在函数中,不适用var声明的变量都会成为全局变量
函数定义了形参就相当于在函数作用域中声明了变量,但是没有传实参过来,形参的值就是undefined

**变量的声明提前**
在全局作用域中，使用**var关键字声明的变量会在所有的代码执行之前被声明，但是不会赋值。**
所以我们可以在变量声明前使用变量。但是不使用var关键字声明的变量不会被声明提前。
在函数作用域中，也具有该特性，使用var关键字声明的变量会在函数所有的代码执行前被声明，
如果没有使用var关键字声明变量，则变量会变成全局变量

**函数的声明提前**
在全局作用域中，使用**函数声明创建的函数（function fun(){}）,会在所有的代码执行之前被创建**，
也就是我们可以在函数声明前去调用函数
但是使用函数表达式(var fun = function(){})创建的函数不会被提前创建
在函数作用域中，使用函数声明创建的函数，会在所有的函数中的代码执行之前就被创建好了。

## this（上下文对象）

我们每次调用函数时，解析器都会将一个上下文对象作为隐含的参数传递进函数。
使用this来引用上下文对象，根据函数的调用形式不同，this的值也不同。

指向当前对象

this的不同的情况：
1.以函数的形式调用时，this是window
2.以方法的形式调用时，this就是调用方法的对象
3.以构造函数的形式调用时，this就是新创建的对象

## 4.构造函数

构造函数是专门用来创建对象的函数
构造函数就是一个普通的函数,创建方式和普通函数没有区别,
不同的是构造函数习惯上首字母大写
构造函数和普通函数的区别就是调用方式的不同
普通函数是直接调用,而构造函数需要使用new关键字来调用

**一个构造函数我们也可以称为一个类**
通过一个构造函数创建的对象，我们称该对象时这个构造函数的实例
通过同一个构造函数创建的对象，我们称为一类对象

例子：

```
function Person(name , age , gender){  
    this.name = name;  
    this.age = age;  
    this.gender = gender;  
    this.sayName = function(){  
        alert(this.name);  
    };  
}  
```

构造函数的执行流程：
1.创建一个新的对象
2.将新建的对象设置为函数中this,在构造函数中可以使用this来引用新建的对象
3.执行函数中的代码
4.将新建的对象返回

**instanceof 用来检查一个对象是否是一个类的实例**
语法：对象 instanceof 构造函数
如果该对象时构造函数的实例，则返回true，否则返回false
**Object是所有对象的祖先，所以任何对象和Object做instanceof都会返回true**

枚举对象中的属性
for...in
语法：

```
for(var 属性名 in 对象){  
  
}  
```

for...in语句的循环体会执行多次，对象中有几个属性就会执行几次，
每次讲一个属性名赋值给我们定义的变量，我们可以通过它来获取对象中的属性

## 原型（prototype）

创建一个函数以后，**解析器都会默认在函数中添加一个数prototype**
prototype属性指向的是一个对象，这个对象我们称为原型对象。
当函数作为构造函数使用，**它所创建的对象中都会有一个隐含的属性执行该原型对象。**

```
这个隐含的属性可以通过对象.__proto__来访问//注意是两个下划线  
```

**原型对象就相当于一个公共的区域，凡是通过同一个构造函数创建的对象他们通常都可以访问到相同的原型对象。**
我们可以将对象中共有的属性和方法统一添加到原型对象中，
这样我们只需要添加一次，就可以使所有的对象都可以使用。
当我们去访问对象的一个属性或调用对象的一个方法时，它会先自身中寻找，
如果在自身中找到了，则直接使用。
如果没有找到，则去原型对象中寻找，如果找到了则使用，
**如果没有找到，则去原型的原型中寻找，以此类推。直到找到Object的原型为止**
**Object的原型为null，因为Object对象的原型没有原型了,如果在 Object原型中依然没有找到则返回undefined**

**使用 in 检查对象中是否含有某个属性**
如果对象中没有但是原型中有,也会返回true

```
console.log("name" in mc);//name是属性，mc是对象，此语句返回true或者false
```

**hasOwnProperty()**
这个方法可以用来**检查对象自身中是否含有某个属性**
语法：对象.hasOwnProperty("属性名")

## toString方法

当我们直接在页面中打印一个对象时，事件上是输出的对象的toString()方法的返回值

如果我们希望在输出对象时不输出[object Object]，可以为对象添加一个toString()方法

```
//修改Person原型的toString  
Person.prototype.toString = function(){  
	return "Person[name="+this.name+",age="+this.age+",gender="+this.gender+"]";  
};  
```

## 垃圾回收（GC）

就像人生活的时间长了会产生垃圾一样，程序运行过程中也会产生垃圾
这些垃圾积攒过多以后，会导致程序运行的速度过慢，
所以我们需要一个垃圾回收的机制，来处理程序运行过程中产生垃圾

当一个对象没有任何的变量或属性对它进行引用，此时我们将永远无法操作该对象，
此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，
所以这种垃圾必须进行清理。
在JS中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，
我们不需要也不能进行垃圾回收的操作
我们需要做的只是要将不再使用的对象设置null即可

```
对象 = null;
```



# 数组（Array）

数组也是一个对象，是一个用来存储数据的对象和Object类似，但是它的存储效率比普通对象要高
数组中保存的内容我们称为元素
数组使用索引（index）来操作元素，索引指由0开始的整数
使用 typeof检查一个数组时,会返回 object


## 数组的操作：

创建数组

```
var arr = new Array();  
var arr = [];  
```

向数组中添加元素
语法；
数组对象[索引] = 值;

```
arr[0] = 123;  
arr[1] = "hello";  
```

创建数组时直接添加元素
语法：

```
 var arr = new Array(元素1,元素2....元素N); 
 var arr = [元素1,元素2....元素N]; 
 var arr = new Array (10)；//当此语句只有一个参数时，此语句是创建一个长度为10的数组
```

例子：

```
 var arr = [123,"hello",true,null];  
```

**获取数组的长度**
使用length属性来操作数组的长度
获取长度：
数组.length
length获取到的是数组的长度(元素的个数)

对于连续的数组，length获取到的就是数组中元素的个数
对于不连续的数组，length获取到的就是数组最大索引+1

**修改数组的长度**
数组.length = 新长度
如果修改后的length大于原长度，则多出的部分会空出来
如果修改后的length小于原长度，则原数组中多出的元素会被删除

**向数组的最后添加元素**
数组[数组.length] = 值;

## 数组的方法

| functionName | function                                                     | usage                                 |
| ------------ | ------------------------------------------------------------ | :------------------------------------ |
| push()       | 用来向数组的末尾添加一个或多个元素，并返回数组新的长度       | 语法：数组.push(元素1,元素2,元素N)    |
| pop()        | 用来删除数组的最后一个元素，并返回被删除元素值               | 语法：数组.pop()                      |
| unshift()    | 向数组的开头插入一个或多个元素，向前边插入元素以后,其他的元素索引会依次调整,最后会返回数组的新的长度 | 语法：数组.unshift(元素1,元素2,元素N) |
| shift()      | 删除数组的开头的一个元素，并返回被删除元素的值               | 语法：数组.shift()                    |
| reverse()    | 可以用来反转一个数组，它会对原数组产生影响                   |                                       |
| concat()     | 可以连接两个或多个数组，它不会影响原数组，而是新数组作为返回值返回 |                                       |
|              |                                                              |                                       |

### slice(sart,[end])

```
 可以从一个数组中截取指定的元素(就是用来从数组提取指定元素)
 该方法不会影响原数组，而是将截取到的内容封装为一个新的数组并返回  
 参数：  
	1.截取开始位置的索引（包括开始位置）  
	2.截取结束位置的索引（不包括结束位置）  
		 第二个参数可以省略不写，如果不写则一直截取到最后  
	  参数可以传递一个负值，如果是负值，则从后往前数
         -1->从倒数第一个开始数
         -2->从倒数第二个开始数
```

### splice()

```
 可以用于删除数组中的指定元素，并使用新的元素替换 
 使用sp1ice()会影响到原数组,会将指定元素从原数组中删除 
 该方法会将删除元素重新返回封装到新数组中   
 参数：  
	1.删除开始位置的索引  
	2.删除的个数  
	3.三个以后，都是替换的元素，这些元素将会插入到开始位置索引的前边  
```

### join([splitor])

可以将一个数组转换为一个字符串
参数：
需要一个字符串作为参数，这个字符串将会作为连接符来连接数组中的元素
如果不指定连接符则默认使用,

### sort()

可以对一个数组中的内容进行排序，默认是按照Unicode编码进行排序
调用以后，会直接修改原数组。
可以自己指定排序的规则，需要一个回调函数作为参数：

我们可以自己来指定排序的规则
我们可以在sort()添加一个回调函数，来指定排序规则，
回调函数中需要定义两个形参,
浏览器将会分别使用数组中的元素作为实参去调用回调函数
使用哪个元素调用不确定，但是肯定的是在数组中a一定在b前边

- 浏览器会根据回调函数的返回值来决定元素的顺序，
  如果返回一个大于0的值，则元素会交换位置
  如果返回一个小于0的值，则元素位置不变
  如果返回一个0，则认为两个元素相等，也不交换位置
- 如果需要升序排列，则返回 a-b
  如果需要降序排列，则返回b-a

```
function(a,b){  
	//升序排列  
	//return a-b;  
	  
	//降序排列  
	return b-a;  
}  
```

## 遍历数组

遍历数组就是将数组中元素都获取到
一般情况我们都是使用for循环来遍历数组

```
for(var i=0 ; i<数组.length ; i++){  
    //数组[i]  
}  
```

使用forEach()方法来遍历数组（不兼容IE8及其以下）

```
数组.forEach(function(value , index , obj){  
  
});  
```

forEach()方法需要一个函数作为参数
像这种由我们创建但是不由我们调用的函数,我们称为回调函数
数组中有几个元素，回调函数就会被调用几次
每次调用时，都会将遍历到的信息以实参的形式传递进来
我们可以定义形参来获取这些信息。
value:正在遍历的元素
index:正在遍历元素的索引
obj:被遍历对象(数组)

# 常用类和方法

## 包装类

在JS中为我们提供了**三个包装类：**
String() Boolean() Number()
通过这三个包装类可以创建基本数据类型的对象
例子：

```
var num = new Number(2);  
var str = new String("hello");  
var bool = new Boolean(true); 
```

但是在实际应用中千万不要这么干。

当我们去操作一个基本数据类型的属性和方法时，
**解析器会临时将其转换为对应的包装类，然后再去操作属性和方法，**
操作完成以后再将这个临时对象进行销毁。

## Date

日期的对象，在JS中通过Date对象来表示一个时间
创建对象
创建一个当前的时间对象

```
 var d = new Date();  
```

创建一个指定的时间对象

```
	var d = new Date("月/日/年 时:分:秒");  
```

### 方法：

| name              |                                                              |
| ----------------- | ------------------------------------------------------------ |
| getDate()         | 当前日期对象是几日（1-31）                                   |
| getDay()          | 返回当前日期对象时周几（0-6） 0 周日 1 周一 。。。           |
| getMonth()        | 返回当前日期对象的月份（0-11） 0 一月 1 二月 。。。          |
| getFullYear()     | 从 Date 对象以四位数字返回年份。                             |
| getHours()        | 返回 Date 对象的小时 (0 ~ 23)。                              |
| getMinutes()      | 返回 Date 对象的分钟 (0 ~ 59)。                              |
| getSeconds()      | 返回 Date 对象的秒数 (0 ~ 59)。                              |
| getMilliseconds() | 返回 Date 对象的毫秒(0 ~ 999)。                              |
| getTime()         | 返回当前日期对象的时间戳 时间戳，指的是从1970年月1日 0时0分0秒，**到现在时间的毫秒数** 计算机底层保存时间都是以时间戳的形式保存的。 |
| Date.now()        | 可以获取当前代码执行时的时间戳                               |

## Math

Math属于一个工具类，它不需要我们创建对象，它里边封装了属性运算相关的常量和方法
我们可以直接使用它来进行数学运算相关的操作
方法：
Math.PI
常量，圆周率
Math.abs()
绝对值运算
Math.ceil()
向上取整
Math.floor()
向下取整
Math.round()
四舍五入取整
Math.random()
生成一个01之间的随机数
生成一个xy之间的随机数
Math.round(Math.random()*(y-x)+x);
Math.pow(x,y)
求x的y次幂
Math.sqrt()
对一个数进行开方
Math.max()
求多个数中最大值
Math.min()
求多个数中的最小值

## 字符串的相关的方法

使用ES6中的字符串新方法

**String.prototype.padStart(maxLength, fillString='')** 或 **String.prototype.padEnd(maxLength, fillString='')**来填充字符串；

length
获取字符串的长度
charAt()
根据索引获取指定的字符
charCodeAt()
根据索引获取指定的字符编码
**String.fromCharCode()**
**根据字符编码获取字符**
indexOf()
lastIndexOf()
从一个字符串中检索指定内容
需要一个字符串作为参数，这个字符串就是要检索的内容，
如果找到该内容，则会返回其第一次出现的索引，如果没有找到则返回-1。
可以指定一个第二个参数，来表示开始查找的位置
indexOf()是从前向后找
lastIndexOf()是从后向前找
slice(start,[end])
可以从一个字符串中截取指定的内容，并将截取到内容返回，不会影响原变量
参数：
第一个：截取开始的位置（包括开始）
第二个：截取结束的位置**（不包括结束）**
可以省略第二个参数，如果省略则一直截取到最后
可以传负数，如果是负数则从后往前数
substr()
和slice()基本一致，不同的是它第二个参数不是索引，而是截取的数量

substring()
和slice()基本一致，不同的是它不能接受负值作为参数，如果设置一个负值，则会自动修正为0，
**substring()中如果第二个参数小于第一个，自动调整位置**
toLowerCase()
将字符串转换为小写并返回
toUpperCase()
将字符串转换为大写并返回
